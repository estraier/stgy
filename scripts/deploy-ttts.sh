#!/usr/bin/env bash
set -euo pipefail

# ====== Embedded "production" config (baked into start.sh) ======
CFG_NODE_ENV=production
CFG_SEARCH_PORT=3200
# Data directory name relative to the installation directory
CFG_SEARCH_INDEX_DIR_NAME=data
CFG_ENABLE_KUROMOJI=true
# =======================================================================

REPO_ROOT="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
OWNER="${DEPLOY_OWNER:-$(id -un)}"
GROUP="${DEPLOY_GROUP:-$(id -gn)}"
TARGET="${DEPLOY_TARGET:-$HOME/stgy-ttts}"

echo "[ttts] Building and staging artifacts..."
cd "$REPO_ROOT"

# Monorepo build (target ttts workspace)
npm ci --workspaces --include-workspace-root
npm run build --workspace ttts
npm prune --omit=dev --workspaces --include-workspace-root

# Prepare target directory
mkdir -p "$TARGET"

# Install runtime assets
rsync -a --delete ttts/dist/              "$TARGET/dist/"
rsync -a            ttts/package.json     "$TARGET/ttts.package.json"
rsync -a --delete node_modules/           "$TARGET/node_modules/"

# Sanity check for entrypoints
if [[ ! -f "$TARGET/dist/index.js" ]]; then
  echo "[error] Missing '$TARGET/dist/index.js' (did the ttts build produce it?)"
  exit 1
fi

# Generate start.sh (self-contained; baked config; supports start/stop/status/restart)
cat > "$TARGET/start.sh" <<'EOS'
#!/usr/bin/env bash
set -euo pipefail

APP_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
cd "$APP_DIR"
RUN_DIR="$APP_DIR/run"
LOG_DIR="$APP_DIR/logs"
DATA_DIR="$APP_DIR/__CFG_SEARCH_INDEX_DIR_NAME__"

mkdir -p "$RUN_DIR" "$LOG_DIR" "$DATA_DIR"

# ===== baked-in config (generated by deploy-ttts.sh) =====
export NODE_ENV='__CFG_NODE_ENV__'
export STGY_SEARCH_PORT='__CFG_SEARCH_PORT__'
export STGY_SEARCH_INDEX_DIR="$DATA_DIR"
export STGY_SEARCH_ENABLE_KUROMOJI='__CFG_ENABLE_KUROMOJI__'
# ===========================================================

NODE_BIN="$(command -v node || true)"
if [[ -z "$NODE_BIN" ]]; then
  echo "[error] 'node' not found in PATH"
  exit 1
fi

pidfile() { echo "$RUN_DIR/$1.pid"; }
is_running() {
  local name="$1" pidfile_path; pidfile_path="$(pidfile "$name")"
  [[ -f "$pidfile_path" ]] || return 1
  local pid; pid="$(cat "$pidfile_path" 2>/dev/null || true)"
  [[ -n "$pid" && -d "/proc/$pid" ]] || return 1
  return 0
}

start_one() {
  local name="$1" entry="$2"
  local log="$LOG_DIR/$name.log" pf; pf="$(pidfile "$name")"
  if is_running "$name"; then
    echo "[$name] already running (pid $(cat "$pf"))"
    return 0
  fi
  echo "[$name] starting..."
  nohup "$NODE_BIN" "$entry" >>"$log" 2>&1 &
  echo $! >"$pf"
  sleep 0.2
  if is_running "$name"; then
    echo "[$name] started (pid $(cat "$pf"))"
  else
    echo "[$name] failed to start; see $log"
    return 1
  fi
}

stop_one() {
  local name="$1" pf; pf="$(pidfile "$name")"
  if ! is_running "$name"; then
    rm -f "$pf"
    echo "[$name] not running"
    return 0
  fi
  local pid; pid="$(cat "$pf")"
  echo "[$name] stopping (pid $pid)..."
  kill -TERM "$pid" 2>/dev/null || true

  # wait up to 10s, then KILL
  for _ in {1..20}; do
    if ! is_running "$name"; then
      break
    fi
    sleep 0.5
  done
  if is_running "$name"; then
    echo "[$name] still alive; killing..."
    kill -KILL "$pid" 2>/dev/null || true
  fi
  rm -f "$pf"
  echo "[$name] stopped"
}

status_one() {
  local name="$1" pf; pf="$(pidfile "$name")"
  if is_running "$name"; then
    echo "[$name] RUNNING (pid $(cat "$pf"))"
  else
    echo "[$name] STOPPED"
  fi
}

start_all() {
  start_one "ttts" "dist/index.js"
}

stop_all() {
  stop_one "ttts"
}

status_all() {
  status_one "ttts"
}

# If launched without args: run in foreground & supervise children.
case "${1:-start}" in
  start)
    trap 'echo "[supervisor] SIGTERM received"; stop_all; exit 0' TERM INT
    start_all
    # Wait until child exits
    while true; do
      if ! pgrep -F "$(pidfile ttts)" >/dev/null 2>&1; then
        echo "[supervisor] ttts process exited; stopping..."
        stop_all
        exit 1
      fi
      sleep 1
    done
    ;;
  stop)
    stop_all
    ;;
  restart)
    stop_all
    start_all
    ;;
  status)
    status_all
    ;;
  *)
    echo "Usage: $0 [start|stop|restart|status]"
    exit 2
    ;;
esac
EOS

# Inject baked config values safely
sed -i \
  -e "s#__CFG_NODE_ENV__#${CFG_NODE_ENV}#g" \
  -e "s#__CFG_SEARCH_PORT__#${CFG_SEARCH_PORT}#g" \
  -e "s#__CFG_SEARCH_INDEX_DIR_NAME__#${CFG_SEARCH_INDEX_DIR_NAME}#g" \
  -e "s#__CFG_ENABLE_KUROMOJI__#${CFG_ENABLE_KUROMOJI}#g" \
  "$TARGET/start.sh"

chmod +x "$TARGET/start.sh"

# Ownership (best-effort if changing user/group)
if [[ "$(id -un)" != "$OWNER" ]] || [[ "$(id -gn)" != "$GROUP" ]]; then
  if command -v sudo >/dev/null 2>&1; then
    sudo chown -R "$OWNER:$GROUP" "$TARGET"
  else
    echo "[warn] Skipping chown (sudo not available): expected $OWNER:$GROUP -> $TARGET"
  fi
fi

echo "[ttts] Deployment completed: $TARGET"
echo "  To run in foreground (recommended for systemd): $TARGET/start.sh"
echo "  To stop:                                      $TARGET/start.sh stop"
echo "  Logs: $TARGET/logs/*.log"
